import{_ as c,r as d,o as t,c as r,a as e,b as n,d as s,e as i}from"./app-6e895db1.js";const l={},o=i(`<h2 id="分支简介" tabindex="-1"><a class="header-anchor" href="#分支简介" aria-hidden="true">#</a> 分支简介</h2><p>暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们）。</p><p>当使用 git commit 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中把这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 <code>blob</code> 对象（保存着文件快照）、一个 <code>树</code> 对象（记录着目录结构和 blob 对象索引）以及一个 <code>提交</code> 对象（包含着指向前述树对象的指针和所有提交信息）。</p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</p><h3 id="分支创建" tabindex="-1"><a class="header-anchor" href="#分支创建" aria-hidden="true">#</a> 分支创建</h3><p>创建分支，它只是为你创建了一个可以移动的新的指针。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch testing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Git 仓库有一个名为 <code>HEAD</code> 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名。</p><h3 id="分支切换" tabindex="-1"><a class="header-anchor" href="#分支切换" aria-hidden="true">#</a> 分支切换</h3><p>要切换到一个已存在的分支。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。</p><p>你可以简单地使用 git log 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code>，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><h2 id="分支的新建与合并" tabindex="-1"><a class="header-anchor" href="#分支的新建与合并" aria-hidden="true">#</a> 分支的新建与合并</h2><h3 id="新建分支" tabindex="-1"><a class="header-anchor" href="#新建分支" aria-hidden="true">#</a> 新建分支</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> iss53

<span class="token comment"># 上面命令是下面两条命令的简写</span>
<span class="token function">git</span> branch iss53
<span class="token function">git</span> checkout iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="合并分支" tabindex="-1"><a class="header-anchor" href="#合并分支" aria-hidden="true">#</a> 合并分支</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hotfix

<span class="token function">git</span> checkout master
<span class="token function">git</span> merge hotfix
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为，master 分支所在提交并不是 hotfix 分支所在提交的直接祖先，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并（C6）。</p><h3 id="删除分支" tabindex="-1"><a class="header-anchor" href="#删除分支" aria-hidden="true">#</a> 删除分支</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token parameter variable">-d</span> iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="分支管理" tabindex="-1"><a class="header-anchor" href="#分支管理" aria-hidden="true">#</a> 分支管理</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch    <span class="token comment"># 当前仓库所有分支的一个列表</span>
<span class="token function">git</span> branch <span class="token parameter variable">-v</span> <span class="token comment"># 查看每一个分支的最后一次提交</span>
<span class="token function">git</span> branch <span class="token parameter variable">--merged</span> <span class="token comment"># 查看哪些分支已经合并到当前分支</span>
<span class="token function">git</span> branch --no-merged <span class="token comment"># 查看所有包含未合并工作的分支</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败，可以使用 <code>-D</code> 选项强制删除它。</p><h2 id="远程分支" tabindex="-1"><a class="header-anchor" href="#远程分支" aria-hidden="true">#</a> 远程分支</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> ls-remote <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span> <span class="token comment"># 来显式地获得远程引用的完整列表， </span>
<span class="token function">git</span> remote show <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span> <span class="token comment"># 获得远程分支的更多信息。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git fetch &lt;remote&gt;</code>，查找 “origin” 是哪一个服务器， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目。</p><h3 id="推送" tabindex="-1"><a class="header-anchor" href="#推送" aria-hidden="true">#</a> 推送</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> push origin serverfix
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="拉取远程分支" tabindex="-1"><a class="header-anchor" href="#拉取远程分支" aria-hidden="true">#</a> 拉取远程分支</h3><p><code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>，比如 <code>git checkout -b serverfix origin/serverfix</code>，本地的名字是可以与远程不同的，比如：<code>git checkout -b sf origin/serverfix</code>。</p><p>如果本地与远程分支名字一样，可以使用捷径 <code>git checkout --track origin/serverfix</code>，该捷径本身还有一个捷径：<code>git checkout serverfix</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token parameter variable">-u</span> origin/serverfix <span class="token comment"># 切换跟踪的远程分支，或 \`--set-upstream-to\`</span>
<span class="token function">git</span> branch <span class="token parameter variable">-vv</span> <span class="token comment"># 查看设置的所有跟踪分支</span>

<span class="token comment"># git branch -vv 没有连接服务器，如果需要，可以使用下方命令组合</span>
<span class="token function">git</span> fetch --all<span class="token punctuation">;</span> <span class="token function">git</span> branch <span class="token parameter variable">-vv</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="拉取" tabindex="-1"><a class="header-anchor" href="#拉取" aria-hidden="true">#</a> 拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。</p><p><code>git pull</code> 会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。使用 fetch 与 merge 命令会更好一些。</p><h3 id="删除远程分支" tabindex="-1"><a class="header-anchor" href="#删除远程分支" aria-hidden="true">#</a> 删除远程分支</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> serverfix
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="变基" tabindex="-1"><a class="header-anchor" href="#变基" aria-hidden="true">#</a> 变基</h2>`,41),p={href:"https://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA",target:"_blank",rel:"noopener noreferrer"},h=i(`<p>变基，指的是将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>将 <code>experiment</code> 分支，然后将它变基到 <code>master</code> 分支上：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 找到最近共同祖先 C2，然后找到当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</span>
<span class="token function">git</span> checkout experiment
<span class="token function">git</span> rebase master

<span class="token comment"># 回到 master 分支，进行一次快进合</span>
<span class="token function">git</span> checkout master
<span class="token function">git</span> merge experiment
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="更有趣的变基例子" tabindex="-1"><a class="header-anchor" href="#更有趣的变基例子" aria-hidden="true">#</a> 更有趣的变基例子</h3><p>假如：主分支的 master 分支，分出开发分支 develop，又从 develop 分出 develop2，各自开发了一段时间之后，要将 develop2 合并到 master，而 develop 暂不合并：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># develop2 变基</span>
<span class="token function">git</span> rebase <span class="token parameter variable">--onto</span> master develop develop2

<span class="token function">git</span> checkout master
<span class="token function">git</span> merge develop2

<span class="token comment"># develop 变基</span>
<span class="token function">git</span> rebase master develop

<span class="token function">git</span> checkout master
$ <span class="token function">git</span> merge develop

<span class="token comment"># 删除无用分支</span>
<span class="token function">git</span> branch <span class="token parameter variable">-d</span> develop
<span class="token function">git</span> branch <span class="token parameter variable">-d</span> develop2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> rebase master develop

<span class="token comment"># 上面命令相当于下面命令，目的不用来回切换分支</span>
<span class="token function">git</span> checkout develop
<span class="token function">git</span> rebase master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="变基的风险" tabindex="-1"><a class="header-anchor" href="#变基的风险" aria-hidden="true">#</a> 变基的风险</h3><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p>`,10),u={href:"https://www.jianshu.com/p/4079284dd970",target:"_blank",rel:"noopener noreferrer"};function v(m,b){const a=d("ExternalLinkIcon");return t(),r("div",null,[o,e("ul",null,[e("li",null,[e("a",p,[n("变基"),s(a)])])]),h,e("ul",null,[e("li",null,[e("a",u,[n("git rebase 还是 merge的使用场景最通俗的解释"),s(a)])])])])}const k=c(l,[["render",v],["__file","3-git-branching.html.vue"]]);export{k as default};
