import{_ as o,r as p,o as c,c as l,a as n,d as a,w as e,b as t,e as i}from"./app-6e895db1.js";const r="/assets/object-4dd82dae.png",u="/assets/object2-ce968f60.png",d={},k={class:"table-of-contents"},m=i(`<h2 id="创建对象有几种方法" tabindex="-1"><a class="header-anchor" href="#创建对象有几种方法" aria-hidden="true">#</a> 创建对象有几种方法</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 方法1（字面量）</span>
<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;o1&#39;</span> <span class="token punctuation">}</span> <span class="token comment">// 打印输出 { name: &quot;o1&quot; }</span>
<span class="token comment">// 或</span>
<span class="token keyword">var</span> o11 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;o11&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 打印输出 { name: &quot;o11&quot; }</span>

<span class="token comment">// 方法2（构造函数）</span>
<span class="token keyword">var</span> <span class="token function-variable function">M</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;o2&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 打印输出 M { name: &quot;o2&quot; }</span>

<span class="token comment">// 方法3（Object.create）</span>
<span class="token keyword">var</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;o3&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> o3 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token constant">P</span><span class="token punctuation">)</span> <span class="token comment">// 打印输出 {}，拿不到name属性，是因为 Object.create 是通过原型链来创建对象的，name在原型链的对象P上</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原型、构造函数、实例、原型链" tabindex="-1"><a class="header-anchor" href="#原型、构造函数、实例、原型链" aria-hidden="true">#</a> 原型、构造函数、实例、原型链</h2><img src="`+r+'"><h3 id="instanceof" tabindex="-1"><a class="header-anchor" href="#instanceof" aria-hidden="true">#</a> instanceof</h3><hr><img src="'+u+`"><ol><li>实例对象虽然由构造函数产生，但是实例的 <code>__proto__</code> 跟构造函数没什么关系，它关联的是构造函数的 <code>prototype</code> 属性所关联的那个原型对象；</li><li>其实instanceof的工作原理就是判断左边实例的 <code>__proto__</code> 和右边构造函数的 <code>prototype</code> 是否一致；</li><li>只要是原型链上的对象，<code>instanceof</code> 都会返回true，但是可以使用 <code>constructor</code> 来判断某实例是否是由某构造函数生成的。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">M</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 其实instanceof的工作原理就是判断左边实例的 __proto__ 和右边构造函数的 prototype 是否一致</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m <span class="token keyword">instanceof</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token comment">// true </span>
<span class="token comment">// 只要是这个原型链上的对象，都会返回true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// constructor 是指创建这个实例的构造函数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">M</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">M</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="new-运算符" tabindex="-1"><a class="header-anchor" href="#new-运算符" aria-hidden="true">#</a> new 运算符</h3><p>new 实际上会经历四个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（this指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加构造函数的属性）；</li><li>返回新对象。</li></ol><p>可以代码来实现上面的四个步骤：</p><ol><li>一个新对象被创建，它继承自Foo.prototype</li><li>构造函数Foo被执行，执行的时候，相应的传参会被传入，同时上下文this会被指定为这个新对象（实例对象）。new Foo 等同于 new Foo()（只能用在不传参数的时候）</li><li>如果构造函数返回的是一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// new运算符的执行过程</span>
<span class="token keyword">const</span> <span class="token function-variable function">new2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 一个新对象被创建，它继承自Foo.prototype</span>
  <span class="token keyword">const</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>
  <span class="token comment">// 构造函数foo被执行，执行的时候，相应的传参会被传入，同时上下文this会被指定为这个新对象（实例对象）。new Foo 等同于 new Foo()（只能用在不传参数的时候）</span>
  <span class="token keyword">const</span> k <span class="token operator">=</span> <span class="token function">Foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>

  <span class="token comment">// 如果构造函数返回的是一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">===</span> &#39;object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> k
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> o
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>【*】如果构造函数有 return，如果返回的是个对象，则会走这个对象；如果返回是非对象（包括null）则会正常返回，不受干扰。</strong></p><p>https://blog.csdn.net/mevicky/article/details/86605882</p>`,17);function v(b,f){const s=p("router-link");return c(),l("div",null,[n("nav",k,[n("ul",null,[n("li",null,[a(s,{to:"#创建对象有几种方法"},{default:e(()=>[t("创建对象有几种方法")]),_:1})]),n("li",null,[a(s,{to:"#原型、构造函数、实例、原型链"},{default:e(()=>[t("原型、构造函数、实例、原型链")]),_:1}),n("ul",null,[n("li",null,[a(s,{to:"#instanceof"},{default:e(()=>[t("instanceof")]),_:1})]),n("li",null,[a(s,{to:"#new-运算符"},{default:e(()=>[t("new 运算符")]),_:1})])])])])]),m])}const _=o(d,[["render",v],["__file","030306.html.vue"]]);export{_ as default};
