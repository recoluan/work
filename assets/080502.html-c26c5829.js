import{_ as e,o,c,e as d}from"./app-6e895db1.js";const i={},r=d("<ol><li><p><code>series</code> 按顺序执行，<code>parallel</code> 并发执行，两者可以混合嵌套到任意层级</p></li><li><p>大多数情况下，插件将放置 <code>.src()</code> 并 <code>.dest()</code> 之间，使用 <code>.pipe()</code> 方法，来转换流中的文件</p></li><li><p><code>.src()</code> 也可以放在管道中间</p></li><li><p><code>.dest()</code> 可以在管道中间使用，以将中间状态输出文件</p></li><li><p>插件通常以缓冲模式运行，许多不支持流模式。如果您需要使用流模式，请寻找支持它的插件或编写自己的插件。</p></li><li><p><code>script/*js</code> 不会包含script以及子集的index.js，<code>script/**/*js</code> 会</p></li><li><p><code>gulp-if</code> 可以让插件按需执行，接受两侧参数(boolean, plugin)</p></li><li><p><code>watch</code> 监控文件的变化执行任务</p></li><li><p><code>babel</code> 报错</p><p><code>babel</code> 运行了先把es6文件编译，然后交给browserify 处理 <code>import</code> 的文件，可是报错了，因为先用 <code>babel</code> 编译 <code>es6</code> 文件后，<code>import</code> <code>export </code>编译成了<code>require</code> <code>module</code> <code>exports</code> 这类，这样 <code>browserify</code> 就可以识别，然后 <code>browserify</code> 就会导入这些import的文件，然后打包进去到 js 文件里面。可是回到babel编译上，有一个问题是 <code>babel</code> 没有把 <code>import</code> 的文件也给编译了，因为 <code>babel</code> 不能导入 <code>import</code> 文件来处理，<code>babel</code> 只是编译了 <code>es6</code> 代码，并不进行 <code>import</code> 的文件的打包处理，所以 <code>import</code> 的文件就没有被babel编译，然后交给 <code>browserify</code> 处理后，会出现 <code>import</code> 文件里的 <code>es6</code> 语法没有被编译。</p><p>这时候解决思路就是再 <code>babel</code> 编译一遍经过 <code>babel-&gt;browserify</code> 后的文件，也就是 <code>babel-&gt;browserify-&gt;babel</code>，这样 <code>import</code> 的文件也会被编译成 <code>es6</code> 语法，不过 <code>babel-&gt;browserify</code> 过程 <code>import</code> 自己写的文件需要用 <code>require</code> 方式导入，export也是需要exports方式导出，这样browserify才能识别，因为browserify不认识 <code>import</code> 文件里的 <code>import</code> 类语法。</p></li></ol>",1),p=[r];function l(t,s){return o(),c("div",null,p)}const a=e(i,[["render",l],["__file","080502.html.vue"]]);export{a as default};
