import{_ as t,r as i,o,c as l,a as n,b as a,d as r,e}from"./app-6e895db1.js";const c={},d=e(`<h2 id="react-组件性能优化" tabindex="-1"><a class="header-anchor" href="#react-组件性能优化" aria-hidden="true">#</a> React 组件性能优化</h2><h3 id="组件内部-参数要少传-减轻react传递数据的负担-尽量使用一份数据-而不是每次使用都重新定义一份" tabindex="-1"><a class="header-anchor" href="#组件内部-参数要少传-减轻react传递数据的负担-尽量使用一份数据-而不是每次使用都重新定义一份" aria-hidden="true">#</a> 组件内部：参数要少传，减轻react传递数据的负担；尽量使用一份数据，而不是每次使用都重新定义一份；</h3><h4 id="属性传递优化" tabindex="-1"><a class="header-anchor" href="#属性传递优化" aria-hidden="true">#</a> 属性传递优化</h4><ol><li>函数制定上下文this，建议在constructor中使用bind(this)。其他的都是在render函数中进行，render每运行一次都会重新处理一次，而constructor中只会运行一次。在render中使用 () =&gt; this.func() 每次都会形成一个新的函数，不好；在render中执行bind就是上面讲的执行多次。</li><li>在组件或着dom上传递属性，比如 <code>&lt;Comp style={ {width: &quot;200px&quot;} }&gt;&lt;/Comp&gt;</code>，这样每次 render 都会新生成一个对象，所以进行把这个对象放到render函数的return上面，或挂在state上或者this上。</li><li><code>&lt;Comp {...this.state}&gt;&lt;/Comp&gt;</code> 不建议，传递了多个属性，可能只需要里面其中一个，可以写成这样：<code>&lt;Comp title={this.state.title}&gt;&lt;/Comp&gt;</code></li></ol><h4 id="多组件优化-在路径加入-react-perf" tabindex="-1"><a class="header-anchor" href="#多组件优化-在路径加入-react-perf" aria-hidden="true">#</a> 多组件优化 (在路径加入 ?react_perf)</h4><ol><li>shouldComponentUpdate(nextProps, nextState) 根据数据的实际变化来动态决定组件是否渲染；如果组件内部没有状态，只靠外部传入的参数（props）来决定渲染，可以使用 React.PureComponent 来代替 React.Component</li><li>不要作深层对比（递归对比，复杂度太高，不可接受，react建议，只做浅对比；React.PureComponent就是用的浅对比，所以在 shouldComponentUpdate 函数中使用下面的方法来做深对比是不可取的）</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">compareObj</span><span class="token punctuation">(</span><span class="token parameter">obj1<span class="token punctuation">,</span> obj2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1 <span class="token operator">==</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">!==</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> obj2<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  
    <span class="token comment">// 下面就是深对比</span>
    <span class="token comment">// if (typeof obj1[k] == &#39;object&#39;) {</span>
    <span class="token comment">//  return compareObj(obj1[k], obj2[k])</span>
    <span class="token comment">// } else if (obj1[k] !== obj2[k]) {</span>
    <span class="token comment">// 	return false</span>
    <span class="token comment">// }</span>
    <span class="token comment">// return true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>immutable-js</li></ol><p>但是我们可以借助 immutable-js 在 shouldComponentUpdate 中进行深对比。</p><ul><li>优点 <ol><li>减少内存使用</li><li>并发安全，可以防止别人替换你的数据</li><li>降低项目复杂度，</li><li>便于比较复杂数据，定制shouldComponentUpdate 方便</li><li>时间旅行功能方便</li><li>函数式编程</li></ol></li><li>缺点 <ol><li>学习成本</li><li>库太大（可以使用seamless-immutable，比较小，提供的方法也比较小）</li><li>对现有项目入侵严重</li></ol></li></ul>`,10),p={id:"key不要使用index-有可能导致第一次执行循环体初始化失败-vue同样适用。文档",tabindex:"-1"},u=n("a",{class:"header-anchor",href:"#key不要使用index-有可能导致第一次执行循环体初始化失败-vue同样适用。文档","aria-hidden":"true"},"#",-1),h={href:"https://juejin.im/post/5a31dda3f265da43052ea207",target:"_blank",rel:"noopener noreferrer"},b=e('<h3 id="组件间-通过-shouldcomponentupdate-函数-provinder组件-。。。" tabindex="-1"><a class="header-anchor" href="#组件间-通过-shouldcomponentupdate-函数-provinder组件-。。。" aria-hidden="true">#</a> 组件间：通过 shouldComponentUpdate 函数；Provinder组件；。。。</h3><h2 id="redux-性能优化" tabindex="-1"><a class="header-anchor" href="#redux-性能优化" aria-hidden="true">#</a> Redux 性能优化</h2><ol><li>reselect 中间件来对计算过程增加缓存（因为redux都是函数，稳定输入稳定输出，所以缓存计算过程来优化性能，特别适用于数据进行大量计算才可以使用的情况）</li></ol><h2 id="react-同构" tabindex="-1"><a class="header-anchor" href="#react-同构" aria-hidden="true">#</a> React 同构</h2><h3 id="首屏采用服务端渲染-其他还和原来一样" tabindex="-1"><a class="header-anchor" href="#首屏采用服务端渲染-其他还和原来一样" aria-hidden="true">#</a> 首屏采用服务端渲染，其他还和原来一样</h3><ol><li>RenderToString和RenderToStaticMarkup</li><li>React16 新出的RenderToNodeStream，性能更好</li><li>React16 里，客户端hydrate取代render</li></ol><h3 id="ssr实战-build代码后的事情" tabindex="-1"><a class="header-anchor" href="#ssr实战-build代码后的事情" aria-hidden="true">#</a> SSr实战，build代码后的事情</h3><h4 id="node使用babel-node配置node里的react环境" tabindex="-1"><a class="header-anchor" href="#node使用babel-node配置node里的react环境" aria-hidden="true">#</a> node使用babel-node配置node里的react环境</h4><ol><li>安装 babel-node，babel-cli（可以执行babel命令），但是es7要使用@babel/node、@babel/cli。package.json中配置script: <code>server: &quot;NODE_ENV=test nodemon --exec babel-node -- server/server.js&quot;</code></li><li>并将babel配置放在 .babelrc 文件中</li></ol><h4 id="修改客户端代码-抽离app组件-前后端共享" tabindex="-1"><a class="header-anchor" href="#修改客户端代码-抽离app组件-前后端共享" aria-hidden="true">#</a> 修改客户端代码，抽离App组件，前后端共享</h4><ol><li>在 服务端引入 <code>import { renderToString, renderToStaticMarkup } from &#39;reacr-dom/server&#39;</code>，通过 <code>renderToString(&lt;Comp&gt;&lt;/Comp&gt;)</code> 来将react代码生成 html字符串 在接口返回</li><li>后端代码中无法识别webpack的别名</li><li>css-modules-require-hook 处理css无法解析的问题</li><li>asset-require-hook 处理图片字体等静态文件</li><li>将css和js文件按倒序渲染在htmlmuban</li><li>服务端生成DOM结构，渲染，加载build后的css和js</li></ol><h2 id="eslint" tabindex="-1"><a class="header-anchor" href="#eslint" aria-hidden="true">#</a> ESlint</h2><ol><li>React-app</li><li>Airbnb</li></ol><h2 id="async-await处理异步" tabindex="-1"><a class="header-anchor" href="#async-await处理异步" aria-hidden="true">#</a> async+await处理异步</h2><h2 id="动画解决方案" tabindex="-1"><a class="header-anchor" href="#动画解决方案" aria-hidden="true">#</a> 动画解决方案</h2><ol><li>css动画（性能好但简单）+ js动画（实现复杂动画，但性能差）</li><li>ReactCSSTransitionGroup</li><li>Ant Motion（又在dom删除新增时才会出发，控制显示和隐藏是不可以的）</li></ol><h2 id="react-16-新特性" tabindex="-1"><a class="header-anchor" href="#react-16-新特性" aria-hidden="true">#</a> React 16 新特性</h2><ol><li>新的核心算法 Fiber，更快（原来调用实例树是递归的，同步，所以会后面需要等待前面的，主线程的时间过长会阻塞后面的；现在是主线程是一部分一部分的进行）</li><li>Render函数可以返回数组、字符串，更智能</li><li>错误处理机制</li><li>Portals组件，可以渲染它DOM节点之外的元素， 比如实现弹窗的灰色模态背景，原来需要放在body，现在可以直接让Portals来测</li><li>更好更快的服务端渲染，renderToNodeString（节点流） 替换 renderToString</li><li>提及更小，完全开源</li></ol>',18);function k(m,v){const s=i("ExternalLinkIcon");return o(),l("div",null,[d,n("h4",p,[u,a(" key不要使用index，有可能导致第一次执行循环体初始化失败，vue同样适用。"),n("a",h,[a("文档"),r(s)])]),b])}const x=t(c,[["render",k],["__file","071602.html.vue"]]);export{x as default};
