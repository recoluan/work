---
title: TypeScript 学习笔记
date: 2019-06-20
tags:
 - js
 - TypeScript
categories: 
 - js
---

## 基础类型

### 布尔值

```js
let let isDone: boolean = false;
```

### 数字

支持数字、十进制、十六进制，还支持ECMAScript 2015 中引入的二进制和八进制。

```js
let decLiteral: number = 6;
```

### 字符串

支持普通字符串和模板字符串。

```js
let name: string = "reco";

let fullname: string = `${ name }_luan`
```

### 数组

```js
// 元素类型后面接上 []
let list: number[] = [1, 2, 3];

// 数组泛型，Array<元素类型>
let list: Array<number> = [1, 2, 3];
```

### 元组 Tuple

可以对数组的每个元素指定数据类型。

```js
let x: [string, number];

// 因为上面指定了两个类型，前两个元素需要一一对应
x = ['hello', 10];

// 如果要声明第三个元素（超过了两个），可以是 string，也可以是 number
x[2] = 1 // 或者 x[2] = '1'
```

如果元素可能会是各种类型，可以这样：

```js
// 元素类型后面接上 []
let list: any[] = [1, '212', null];
```

### 枚举

#### 介绍

使用枚举类型可以为一组数值赋予友好的名字。枚举会根据你的定义产生两套 `key: value` 数据，比如：

```js
enum Color { Red, Green, Blue }

console.log(Color) // {0: "Red", 1: "Green", 2: "Blue", Red: 0, Green: 1, Blue: 2}
```

默认情况下，从0开始为元素编号。可以手动的指定数值的起始值或者是给每个数值进行自定义。

```js
enum Color { Red = 1, Green, Blue }

console.log(Color) // {1: "Red", 2: "Green", 3: "Blue", Red: 1, Green: 2, Blue: 3}
```

```js
enum Color { Red = 1, Green = 2, Blue = 4 }

console.log(Color) // {1: "Red", 2: "Green", 4: "Blue", Red: 1, Green: 2, Blue: 4}
```

#### 使用


```js
enum Color {Red, Green, Blue}

let c: Color = Color.Green
let colorName: string = Color[2]

console.log(c) // 1
console.log(colorName) // "Blue"
```

#### 枚举类型的区别

1. 普通枚举

    ```js
    enum Enum {
      A
    }
    let a = Enum.A;
    let nameOfA = Enum[Enum.A]; // "A"
    ```

    被编译成：

    ```js
    var Enum;
    (function (Enum) {
      Enum[Enum["A"] = 0] = "A";
    })(Enum || (Enum = {}));
    var a = Enum.A;
    var nameOfA = Enum[Enum.A]; // "A"
    ```

2. 常数枚举
    
    增加关键字 `const`

    ```js
    const enum Enum {
      A = 1*8,
      B = A * 2
    }
    var re=Enum.A;
    console.log( re);
    ```

    被编译成：

    ```js
    var re = 8 /* A */;
    console.log(re);
    ```

3. 外部枚举

    增加关键字 `declare`

    ```js
    declare enum Enum {
      A = 1,
      B,
      C = 2
    }
    var re=Enum.A;
    console.log(re);
    ```

    被编译成：

    ```js
    var re = Enum.A;
    console.log(re);
    ```

#### 注意

[参考](https://www.jianshu.com/p/42241a597a50)

1. 强烈不建议将枚举项的值设置为字符串类型；
2. 首个枚举项值设置为 1；
3. 尽量不要为多个枚举项手动设置值；

### Any

可以指定任意类型，可以调用任意方法。

### Void

`void` 类型像是与 `any` 类型相反，它表示没有任何类型，只能为它赋予 `undefined` 和 `null`。

当一个函数没有返回值时，你通常会见到其返回值类型是 void：

```js
function warnUser(): void {
  console.log("This is my warning message");
}
```

### Null 和 Undefined

`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`， 和 `void` 相似。

默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` `和undefined` 赋值给 `number` 类型的变量。当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自。

### Never

`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。

### Object

`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbo`l，`null` 或 `undefined` 之外的类型。

```js
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

## 接口

### 初识

```ts
function printLabel (labelledObj: { label: string }) {
  console.log(labelledObj.label)
}

let myObj = { size: 10, label: 'Size 10 Object' }

printLabel(myObj)
```

上面的校验我们就可以使用接口来实现：

```ts
interface LabelledValue {
  label: string
}

function printLabel (labelledObj: LabelledValue) {
  console.log(labelledObj.label)
}
```

### 可选属性

```ts
interface Square {
  color: string,
  area: number
}

interface SquareConfig {
  color?: string,
  width?: number
}

function createSquareFn (config: SquareConfig): Square {
  let initConfig = { color: '#fff', width: 100 }

  if (config.color) { 
    initConfig.color = config.color
  }
  if (config.width) { 
    initConfig.width = config.width
  }

  return {
    color: initConfig.color,
    area: initConfig.width * initConfig.width
  }
}

const newSquareConfig: Square = createSquareFn({ color: 'red' })
console.log(newSquareConfig)
```

### 只读属性

```ts
interface Point {
  readonly x: number,
  readonly y: number
}

let pt: Point = {
  x: 10,
  y: 10
}

pt.x = 20 // 这里会报错，因为这里是只读属性
```

```ts
let a: number[] = [1, 2, 3, 4]
let ro: ReadonlyArray<number> = a

ro[0] = 12 // 报错1，因为这个数组是只读数组

ro.push(12) // 报错2，因为这个数组是只读数组

ro.length = 100 // 报错3，因为这个数组是只读数组

a = ro // 报错4，因为这个数组是只读数组
a = ro as number[] // 解决报错4，使用“类型断言”
```

`readonly` 和 `const` 分别怎么去使用呢？看是作为什么角色使用，如果作为一个变量使用 `const`，作为一个属性使用 `readonly`。

### 额外属性检查

**案例1**

```ts
interface LabelledValue {
  label: string
}

function printLabel (labelledObj: LabelledValue) {
  console.log(labelledObj.label)
}

let myObj = { size: 10, label: 'Size 10 Object' }

printLabel(myObj)
```

比如上面这个例子，我们并没有对 `size` 做校验，这个时候可以这样做：

```ts
interface LabelledValue {
  label: string,
  [propName: string]: any
}

function printLabel (labelledObj: LabelledValue) {
  console.log(labelledObj.label)
}

let myObj = { size: 10, label: 'Size 10 Object' }

printLabel(myObj)
```

**案例2**

```ts
interface Square {
  color: string,
  area: number
}

interface SquareConfig {
  color?: string,
  width?: number
}

function createSquareFn (config: SquareConfig): Square {
  let initConfig = { color: '#fff', width: 100 }

  if (config.color) { 
    initConfig.color = config.color
  }
  if (config.width) { 
    initConfig.width = config.width
  }

  return {
    color: initConfig.color,
    area: initConfig.width * initConfig.width
  }
}

const newSquareConfig: Square = createSquareFn({ colour: 'red' })
console.log(newSquareConfig)
```

比如上面这个例子，我们将 `color` 错拼为 `colour`，会提示，`colour` 并不在类型中：

```ts
interface SquareConfig {
  color?: string,
  width?: number,
  [propName: string]: any
}
```

### 函数类型

```ts
interface SearchFunc {
  (source: string, subString: string): boolean
}

let mySearch: SearchFunc = function (source: string, subString: string): boolean {
  let result = source.search(subString)
  return result > -1
}
```

其实函数里的行参可以和接口里的属性名字不一致：

```ts
let mySearch: SearchFunc = function (a: string, b: string): boolean {
  let result = a.search(b)
  return result > -1
}
```

甚至语法检测也不用写：

```ts
let mySearch: SearchFunc = function (a, b) {
  let result = a.search(b)
  return result > -1
}
```

### 描述索引得到一个类型

```ts
interface StringArray {
  [index: number]: string
}

let myArr: StringArray = ['Bob', 'Fred']

let myStr: string = myArr[0]
```

`typescript` 是支持两种索引签名的：`String` 和 `Number`，数字类型的返回值必须是字符串类型返回值的子类型，因为 `myArr[0]` 会被转成 `myArr['0']`，比如：

```ts
class Animal {
  name: string
}

class Dog extends Animal {
  brees: string
}

interface NotOkey {
  [x: number]: Animal,
  [y: string]: Dog
}
```

调换一下位置就可以了：

```ts
interface NotOkey {
  [x: number]: Dog,
  [y: string]: Animal
}
```

---

```ts
interface NumberDictionary {
  [index: string]: number,
  length: number, // 不报错
  name: string // 报错
}
```

---

```ts
interface ReadonlyStringArr {
  readonly [index: number]: string
}

let myArr: ReadonlyStringArr = ['Bob', 'Alice']
myArr[1] = 'reco' // 报错
```

### 类的接口实现

类有两种类型，一种是实例类型，一种是静态类型

```js
// 实例接口
interface ClockInterface {
  tick()
}

// 构造器接口
interface ClockConstructor {
  // 这里叫做构造器签名
  new (hour: number, minute: number): ClockInterface
}

// implements 只能检测类的实例部分，也就是静态方法
class DigitalClock implements ClockInterface {
  constructor (h: number, m: number) {

  }

  tick () {
    console.log('beep beep')
  }
}

class AnalogClock implements ClockInterface {
  constructor (h: number, m: number) {

  }

  tick () {
    console.log('tick toc')
  }
}

// 所以通过一个函数，在参数里对构造器部分进行类型检测
function createClock (clor: ClockConstructor, hour: number, minute: number): ClockInterface {
  return new clor (hour, minute)
}

let digital = createClock(DigitalClock, 12, 10)
let analog = createClock(AnalogClock, 12, 10)
```

### 接口继承

```ts
interface Shape {
  color: string
}

interface PenStroke {
  penWidth: number
}

interface Square extends Shape {
  sideLength: number
}

let square = {} as Square
square.color = 'blue'
square.sideLength = 10

// 还可以多个继承
interface Demo extends Shape, PenStroke {
  name: string
}
```

### 接口继承类

```ts
// 接口除了继承接口，还可以把继承的接口写作类，但是不建议这样做，除非某个接口有类的特性
// 所以类也可以单独当做类型来用

// 接口继承类，可以继承这个类的成员，但不包括它的实现，就好像一个类声明了类所有的成员，但没有提供和具体实现一样。

// 接口会继承类的 private 和 protect 成员，也就是私有的和受保护的成员，这就意味着，如果我们创建一个接口，并继承一个拥有私有和受保护的成员的类的时候，那接口的类型只能被这个类及其子类所实现。

class Control {
  private state: any
}

interface SelectableControl extends Control {
  select ()
}

class Button extends Control implements SelectableControl {
  select () {}
}

class TextBox extends Control {
  select () {}
}

// 这里会报错，因为 ImageC 没有继承 Control，所以里面的私有属性 state 并没有
class ImageC implements SelectableControl {
  select () {}
}
```

### 接口混合类型

```ts
interface Counter {
  (start: number): string,
  interval: number,
  reset(): void
}

function getCounter(): Counter {
  let counter = (function (start: number) {}) as Counter

  counter.interval = 123
  counter.reset = function () {}

  return counter
}

let c = getCounter()
c(10)
```

### 类-公有、私有

```ts
class Animal {
  private name: string

  // 普通的写法默认是 public 属性，同 public constructor
  constructor (name: string) {
    this.name = name
  }

  move (distance: number = 0) {
    console.log(`${this.name} moved ${distance}m`)
  }
}

class Cat extends Animal {
  constructor (name) {
    // 当不需要参数的时候，可以 super('Cat')
    super(name)
  }
}

class Emplyee {
  name: string
  constructor (name: string) {
    this.name = name
  }
}

let animal = new Animal('Goat')
let cat = new Cat('mimi')
let employee = new Emplyee('Bob')

console.log(animal.name) // 报错，私有属性不能在类的外面使用
console.log(cat.name) // 报错，私有属性也不能子类（包括里面和外面）使用
console.log(employee.name)

animal = cat
animal = employee // 报错，因为两个类的 name 不同，employee 的 name 是私有属性，所以不兼容
```

### 类-受保护属性

```ts
class Person {
  protected name: string

  // 如果构造器添加 protected，将不可以 new（实例化），但是子类可以，**非常重要**
  constructor (name: string) {
    this.name = name
  }
}

class Employee extends Person {
  private department: string

  constructor (name: string, department: string) {
    super(name)
    this.department = department
  }

  getElevatorPitch () {
    return `Hello, my name is ${this.name} and I work in ${this.department}.`
  }
}

let howard = new Employee('Howard', 'Programme')
console.log(howard.getElevatorPitch())
console.log(howard.name) // 报错，受保护属性，可以在类和子类内部使用，但不可以在外部使用
```

### 类-readonly 和参数属性

```ts
class Person {
  readonly name: string

  constructor(name: string) {
    this.name = name
  }
}

let john = new Person('John')
console.log(john.name)
john.name = 1 // 报错，只读

// 参数简写

class Person2 {
  constructor(readonly name: string) {}
}
```

### 类-抽象类

```ts

// 抽象类通常作为其他派生类的基类使用
abstract class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }

  // 也可以包含一些其他的方法的实现
  printName(): void {
    console.log(`My name is ${this.name}!`)
  }

  // 抽象类可以包含 abstract 类属性，但是此类属性不可以被实现，只能在派生类中实现
  // 也可以包含一些访问修饰符 protect 等等
  abstract say(): void
}

class Reco extends Person {
  constructor() {
    super('reco')
  }

  say() {
    console.log(`${this.name} is saying!`)
  }

  play () {
    console.log(`${this.name} like to play football!`)
  }
}

const reco: Person = new Reco()
reco.printName()
reco.say()
reco.play() // 报错，因为制定 reco 的类型为 Person，Person 中并没有 play，如果为 Reco 就不报错了
```

### 类-静态属性

```ts
class Message {
  static firstName = 'Luan'

  secondName: string

  constructor(secondName?: string) {
    this.secondName = secondName
  }

  getMessage () {
    if (this.secondName) {
      return `Hello, ${this.secondName}!`
    } else {
      // 静态属性需要使用 类名 来访问
      return `Hello, ${Message.firstName}!`
    }
  }
}

let message: Message
message = new Message()
console.log(message.getMessage())

// 重新创建一个 Message 类型的构造器，使用 typeof，这样就可以直接来修改静态属性了
let MessageMaker: typeof Message = Message
MessageMaker.firstName = 'Wang'
let message2: Message
message2 = new MessageMaker()
console.log(message2.getMessage())
```
