---
title: 原型链
date: 2019-03-03
---

[[toc]]

## 创建对象有几种方法

```javascript
// 方法1（字面量）
var o1 = { name: 'o1' } // 打印输出 { name: "o1" }
// 或
var o11 = new Object({ name: 'o11' }) // 打印输出 { name: "o11" }

// 方法2（构造函数）
var M = function () {
  this.name = 'o2'
}
var o2 = new M() // 打印输出 M { name: "o2" }

// 方法3（Object.create）
var P = { name: 'o3' }
var o3 = Object.create(P) // 打印输出 {}，拿不到name属性，是因为 Object.create 是通过原型链来创建对象的，name在原型链的对象P上
```

## 原型、构造函数、实例、原型链

<img src="../images/object.png" />

#### instanceof

---

<img src="../images/object2.png" />

1. 实例对象虽然由构造函数产生，但是实例的 `__proto__` 跟构造函数没什么关系，它关联的是构造函数的 `prototype` 属性所关联的那个原型对象；
2. 其实instanceof的工作原理就是判断左边实例的 `__proto__` 和右边构造函数的 `prototype` 是否一致；
3. 只要是原型链上的对象，`instanceof` 都会返回true，但是可以使用 `constructor` 来判断某实例是否是由某构造函数生成的。

```javascript
const M = function () {}
const m = new M()

// 其实instanceof的工作原理就是判断左边实例的 __proto__ 和右边构造函数的 prototype 是否一致
console.log(m instanceof M) // true 
// 只要是这个原型链上的对象，都会返回true
console.log(m instanceof Object) // true

// constructor 是指创建这个实例的构造函数
console.log(m.constructor === M) // true
console.log(m.__proto__.constructor === M) // true
```
