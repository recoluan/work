---
title: 面向对象
date: 2019-03-03
---

[[toc]]

:::tip 概念
面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。然后，`ECMAScript` 中**没有类的概念**，所以它的对象也与基于类的语言中的对象有所不同。

`ECMA-262` 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”也可以说对象是一组无序的 `Key-Value`。
:::

## 对象属性

### 属性类型

数据属性和访问属性。

#### 数据属性

- [[Configurable]]：（默认 `true`）表示能否 `delete` 删除属性并重新定义，能否修改属性的特性，能否把属性改为访问器属性。
- [[Enumerable]]：（默认 `true`）表示能否通过 `for-in` 循环返回属性。从而可以看出 `[[Configurable]]` 包含 `[[Writable]]`。
- [[Writable]]：（默认 `true`）表示能否修改属性。
- [[Value]]：（默认 `undefined`）表示当前属性的值。因此访问一个未定义的值就会返回 `undefined`。赋值也是去修改 `[[Value]]`。

可以使用 `ECMAScript 5` 的 `Object.definePrototype()` 方法来修改数据属性，设置属性时属性 Key 分别为 `configurable`、`enumerable`、`writable`、`value`：

```js
const person = {}

// 因为 configurable 作用范围更大，所以设置 configurable: false，相当于设置 writable: false
Object.definePrototype(person, "name", {
  writable: false, // 不可编辑
  value: "reco"
})

console.log(person.name) // reco
person.name = 'luan'
console.log(person.name) // reco
```

可以调用 `Object.definePrototype()` 多次修改同一数据属性，但是设置 `configurable: false` 之后，就不能再设置为 `true` 了，`configurable` 属性的设置是不可逆的。

ES5有三个操作会忽略enumerable为false的属性：

1. for-in循环：只遍历对象自身的和继承的可枚举的属性
2. Object.keys()：返回对象自身的所有可枚举的属性的键名
3. JSON.stringify()：只串行化对象自身的可枚举的属性
4. hasOwnProperty：只有对象自身的可枚举的属性返回 true

ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。

toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。

#### 访问器属性

访问器属性不包括 `[[Writable]]` 和 `[[Value]]`，包含一对儿 `set` 和 `get` 函数（不必须）来控制属性 Value 的写入和读取。

- [[Configurable]]：（默认 `true`）表示能否 `delete` 删除属性并重新定义，能否修改属性的特性，能否把属性改为访问器属性。
- [[Enumerable]]：（默认 `true`）表示能否通过 `for-in` 循环返回属性。从而可以看出 `[[Configurable]]` 包含 `[[Writable]]`。
- [[Get]]：（默认 `undefined`）读取属性时调用此函数。
- [[Set]]：（默认 `undefined`）写入属性时调用此函数。

```js
const book = {
  _year: 2020,
  edition: 1
}

Object.defineProperty(book, 'year', {
  get () {
    return this._year
  },

  set (newValue) {
    if (newValue > 2019) {
      this._year = newValue
      this.edition += newValue - 2019
    }
  }
})

book.year = 2020
console.log(book) // { _year: 2020, year: 2020, edition: 2 }
```

以上代码创建了一个 book 对象，并定义两个默认属性：_year 和 edition。_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。访问器属性 `year` 的 getter 函数返回 _year 的值，setter 函数通过计算来确定新的版本。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

上面这段话比较学术，下面用通俗的语言介绍上面的代码：

1. 其中 _year 和 edition 是数据属性，year 访问器属性。**数据属性包含一个数据的位置，在这个位置可以读取和写入值，而访问器属性是没有位置的。**getter 和 setter 函数是不能操作修改和读取访问器属性的；
2. 当读取访问器属性时，其实访问的数 getter 函数，设置访问器属性时，访问的数 setter 函数。

:::tip 延伸
javascript 其实一共用三种属性:
- 数据属性：这种属性是用户赋给它们，它们就返回什么，不会做额外的事情；
- 内部属性：比如数组的length属性，函数的prototype属性，DOM节点的innerHTML属性，用户对它们进行赋值后，再取值时，它不一定按我们的预期做事，此外还会做一些格外的事情。另外，我们也很难改变它们的行为。
- 访问器属性：允许用户在赋值或取值都经过预先设定的函数，从而实现内部属性的那一种特殊效果。

`Object.defineProperty()` 定义访问器属性时，`getter/setter` 和 `configurable/enumerable` 是不能同时出现的。

上面访问器属性的相关代码可以省略 `Object.defineProperty()`（仅有setter和getter函数时可以省略），简写为：

```js
const book = {
  _year: 2020,
  edition: 1,
  get year () {
    return this._year
  },

  set year (newValue) {
    if (newValue > 2019) {
      this._year = newValue
      this.edition += newValue - 2019
    }
  }
}
```

下面再延伸访问器属性的几种用法：

1. 有了 get 和 set 我们就可以在返回和设置值的时候进行一些额外的操作：
    ```js
    var obj = {
      n: 67,
      get id () {
        return 'The ID is: ' + this.n;
      },
      // 判断是否是数字
      set id (val) {
        if (typeof val === 'number') {
          this.n = val;
        }
      }
    }  

    console.log(obj.id);
    // "The ID is: 67"
    
    obj.id = 893;
    
    console.log(obj.id);
    // "The ID is: 893"
    
    obj.id = 'hello';
    
    console.log(obj.id);
    // "The ID is: 893"
    ```
2. 结合访问器属性，我们可以实现数据的私有化
    ```js
    // 1. 利用块级作用域。
    {
      let fooVal = 'this is the value of foo';
      var obj = {
        get foo() {
            return fooVal;
        },
        set foo(val) {
            fooVal = val
        }
      }
    }
    
    fooVal = 'hello';
    // not going to affect the fooVal inside the block
    
    console.log(obj.foo);
    // "this is the value of foo"
    ```
    ```js
    // 2. 利用函数作用域
    function myobj(){
      var fooVal = 'this is the value of foo';
      return {
          get foo() {
              return fooVal;
          },
          set foo(val) {
              fooVal = val
          }
      }
    }
    
    fooVal = 'hello';
    // not going to affect our original fooVal
    
    var obj = myobj();
    
    console.log(obj.foo);
    // "this is the value of foo"
    ```
:::

### 定义多个属性

```js
var book = {};

Object.defineProperties(book, {
  _year:{
    writeable:true,
    value:2004
  },
  edition:{
    writeable:true,
    value:1
  },
  year:{
    get () {
      return this._year
    },
    set (newValue){
      if (newValue > 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
})

book.year = 2005;
alert(book.edition);
```

### 读取属性的特性

```js
const book = {
  _year: 2020,
  edition: 1,
  get year () {
    return this._year
  },

  set year (newValue) {
    if (newValue > 2019) {
      this._year = newValue
      this.edition += newValue - 2019
    }
  }
}

const descriptor = getOwnPropertyDescriptor(book, '_year')
console.log(descriptor.value) // 2020
console.log(descriptor.configurable) // false
console.log(typeof descriptor.get) // undefined

const descriptor = getOwnPropertyDescriptor(book, 'year')
console.log(descriptor.value) // undefined
console.log(descriptor.configurable) // false
console.log(typeof descriptor.get) // "function"
```

## 创建对象

```js
// 通过 字面量 创建对象
const person = {
  name: 'reco',
  age: 18
}

// 通过构造函数 Object 创建对象
const person = new Object()
person.name = 'reco'
person.age = 18
```

上面这两种方式是创建的单个对象的最基本的方式。但是在通过一个接口创建多个对象时会产生大量重复代码。未解决这个问题，开发人员开始使用工厂模式的一种变体。

::: tip 单纯比较上面两种方式
字面量的优势：
1. 它的代码量更少，更易读；
2. 它可以强调对象就是一个简单的可变的散列表，而不必一定派生自某个类；
3. 对象字面量运行速度更快，因为它们可以在解析的时候被优化——它们不需要"作用域解析"！因为存在我们创建了一个同名构造函数Object()的可能，所以当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上找，直到找到全局Object()构造函数为止；
4. 切记，通过字面量调用对象，实际上是不调用 Object 构造函数的，虽然平时我们会说 `{}` 是和 `new Object()` 相等的。

构造函数的优势：
1. Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数（Number()、String()等），并返回另一个对象实例；
2. 使用自定义构造函数创建对象，可以通过传参添加属性和方法，当需要定义的同类对象较多时，节省了定义对象的代码量，并且使对象属性和方法的结构更加清晰。
:::

### 工厂模式

工厂模式，用函数封装 **以特定的接口创建对象** 的过程。

```js
function createPerson (name, age) {
  const o = new Object()
  o.name = name
  o.age = age
  a.sayName = function () {
    console.log(this.name)
  }
  return o
}

const reco = createPerson('reco', 18)
```

工厂模式解决了创建多个相似对象代码重复冗余的问题，但是没有对象识别（如何知道一个对象的类型）的问题。所以构造函数模式出现了。

### 构造函数模式

#### 简介

内置的构造函数比如 `Arrary/Object` 可以创建特定类型的对象，我们也可以通过自定义的构造函数，从而定义自定义对象类型的属性和方法。

```js
function Person (name, age) {
  this.name = name
  this.age = age
  this.sayName = function () {
    console.log(this.name)
  }
}

const reco = new Person('reco', 18)
```

借鉴其他 OO 语言，将构造函数名首字母大写，仅为了区分普通函数，只有当它使用 new 来调用时才是构造函数。

以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 Window 对象）中的。在全局作用域中调用一个函数时，this 对象总是指向 Global 对象（在浏览器中是 Window 对象）。

#### 缺点

每个方法都要在每个实例中重新创建一遍。

因为 ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化一个 Function 对象，所以上面的案例可以这样改造：

```js
function Person (name, age) {
  this.name = name
  this.age = age
  this.sayName = new Function("console.log(this.name)")
}

const reco = new Person('reco', 18)
```

所以可以看出，如果创建两个 Person 的实例，创建两个 Function 实例是没有必要的，况且函数中有 this 对象在，无序将函数绑定到特殊对象上面，从而可以将创建 Function 实例放在构造函数外面来解决：

```js
function Person (name, age) {
  this.name = name
  this.age = age
  this.sayName = sayName
}

function sayName {
  console.log(this.name)
}

const reco = new Person('reco', 18)
```

####  new 运算符

new 实际上会经历四个步骤：
1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（this指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加构造函数的属性）；
4. 返回新对象。

可以代码来实现上面的四个步骤：

1. 一个新对象被创建，它继承自Foo.prototype
2. 构造函数Foo被执行，执行的时候，相应的传参会被传入，同时上下文this会被指定为这个新对象（实例对象）。new Foo 等同于 new Foo()（只能用在不传参数的时候）
3. 如果构造函数返回的是一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象

```javascript
// new运算符的执行过程
const new2 = function (Foo) {
  // 一个新对象被创建，它继承自Foo.prototype
  const o = Object.create(Foo)
  // 构造函数foo被执行，执行的时候，相应的传参会被传入，同时上下文this会被指定为这个新对象（实例对象）。new Foo 等同于 new Foo()（只能用在不传参数的时候）
  const k = Foo.call(o)

  // 如果构造函数返回的是一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象
  if (typeof k === 'object) {
    return k
  } else {
    return o
  }
}
```

### 原型模式

我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例的属性和方法。所以可以在构造函数的原型上去添加实例可以共享的属性和方法：



## 类与继承

> 继承是 `OO`（面向对象） 语言一个概念，多数支持 `接口继承`（继承方法签名） 和 `实现继承`（继承实际的方法），但是 `ECMAScript` 中**只支持** `实现继承`，并且主要依赖原型链来实现。

### 1. 原型链

#### 原理

将父类的实例赋值给子类的 `prototype`（原型对象）。通过实现原型链，本质上扩展了原型链搜索机制。

#### 原型链搜索机制

当读取一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。通过原型链实现继承的情况下，搜索过程会沿着原型链继续向上搜索。

```javascript
function Parent () {
  this.name = 'reco'
  this.heby = [1, 2, 3, 4]
}
Parent.prototype.say = function () {
  console.log('hello')
}

function Child () {
  this.age = 10
}

// 将子构造函数的原型对象指向父构造函数的实例对象，进而继承父构造函的原型对象
Child.prototype = new Parent()

const child1 = new Child()
const child2 = new Child()

child1.name = 'reco1'
child1.heby.push(5)

console.log(child1.name, child2.name) // reco1, reco
console.log(child1.heby, child2.heby) // [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]
```

`child1.constructor` 指向了 `Parent`，如果不继承，应该指向 `Child`。

#### 默认原型

所有引用类型都默认继承了 `Object`，即所有函数的默认原型都是 `Object` 的实例，所以默认原型都会包含一个内部指针指向 `Object.prototype`，也因此都继承了 `Object` 的 `toString()` 和 `valueIf()`。

#### 验证原型和实例的关系

通过 `instanceof` 来验证：

```js
console.log(child1 instanceof Object) // true
console.log(child1 instanceof Parent) // true
console.log(child1 instanceof Child)  // true
```

或者通过 `isPrototypeOf` 来验证：

```js
console.log(Object.prototype.isPrototypeOf(child1)) // true
console.log(Parent.prototype.isPrototypeOf(child1)) // true
console.log(Child.prototype.isPrototypeOf(child1))  // true
```

#### 注意事项

1. 先给子类替换原型，再去定义或重构方法
    ```js
    // 先给子类替换原型
    Child.prototype = new Parent()

    // 再去定义或重构方法，不然会被覆盖
    Child.prototype.eat = function () {}
    ```
2. 不要使用字面量给子类创建原型方法
    ```js
    Child.prototype = new Parent()

    // 下面方法会覆盖上面的代码，导致替换原型无效
    Child.prototype = {
      eat: function () {}
    }
    ```

#### 缺点

1. 由于每个子类实例共有父类的属性，且如果为引用类型时，一个实例改变这个属性的值，另一个实例也随之改变。

   当父类的实例赋值给子列的 `prototype` 的时候，相当于父类的实例属性被放到了子列的原型属性上而被共用，如果为引用类型,这样一个s实例改变，另一个也改变了（如果都是通过 `=` 重新赋值，无论是引用类型还是值类型，都是在实例上重新定义了此属性，这样就都拿不到父类的这个属性了）。
2. 无法给父类传参
   
   准确的说是，无法在不影响所有子类实例的情况下给父类传参。因为父类的实例化是在子类创建原型属性时进行的，只执行一次，子类的实例化时就不会再执行了，所以无法在子类实例化话给父类构造函数传参了。

### 2. 借助构造函数

也叫 `伪造对象` 或者 `经典继承`。

#### 原理

在子类的构造函数中调用父类构造函数。函数只不过是在特定环境中执行代码的对象，因此可以通过 `call/apply/bind` 在创建子类实例时运行父类构造函数，并将父类的实例属性挂载到子类的 `this` 上。

```javascript
function Parent () {
  this.name = 'reco'
}
Parent.prototype.say = function () {
  console.log('hello')
}

function Child () {
  Parent.call(this) // apply也可以，bind需要执行一下，即Parent.bind(this)()
  this.age = 10
}

console.log(new Child())
```

#### 注意

- 在子类构造函数中，先调用父类构造函数，再定义自己的属性
    ```js
    function Child () {
      // 先调用父类构造函数
      Parent.call(this)

      // 再定义自己的属性
      this.age = 10
    }
    ```

#### 缺点

1. 可以继承构造函数本身的属性，却不能继承原型上的属性, `name` 可以继承， `say` 不可以继承；
2. 继承的方法在子类中也是实例属性，所以无法复用。

### 3. 组合方式

也叫 `伪经典继承`，JS 中最常用的继承模式。

#### 原理

使用原型链实现原型属性和方法的继承，而通过构造函数实现对实例属性的继承。

```javascript
function Parent () {
  this.name = 'reco'
}
Parent.prototype.say = function () {
  console.log('hello')
}

function Child () {
  // 1. 继承实例属性和方法
  Parent.call(this)
  this.age = 10
}

// 2. 继承原型属性和方法
Child.prototype = new Parent()

// 3. 恢复子类的原型的构造函数
Child.prototype.constructor = Child

console.log(new Child())
```

#### 注意

1. 截止到第 2 步，有个问题，就是子类的原型指向了父类的原型，所以其构造函数也就指向了 `Parent`，所以需要第 3 步恢复一下子类型的构造函数。
2. 第 2 步为什么不使用 `Child.prototype = Parent.prototype`？因为第 3 步会导致父类原型的构造函数也会变为子类构造函数。
3. 第 2 也可以使用 `Child.prototype = Object.create(Parent.prototype)`，这样也就会有一个好处， `Object.create()` 返回是以 `Parent` 为原型的实例，`Child.prototype` 也就不会有 `Parent` 的实例属性 `name`，从而就是去除了实例属性 `name`的重复，因为第 1 步已经实现了实例属性的继承。

【注意3】中讲到了 `Object.create()`，它仅支持 `IE9+`，在传入一个参数的时候等同于下面的实现：

```js
function object (o) {
  function F () {}
  F.prototype = o
  return new F()
}
```

#### 缺点

组合继承最大的缺点就是父类构造函数执行了两次。

::: tip
这个在【注意3】中其实得到了解决，原因在下面的寄生组合继承中讲解。
:::

### 4. 原型式继承

道格拉斯·克罗克福德 介绍了下面这种继承：

```js
function object (o) {
  function F () {}
  F.prototype = o
  return new F()
}
```

也就是上面提到的 `Object.create()` 在传入一个参数时候的实现原理。

```js
const person = {
  name: 'reco',
  friends: [1, 2, 3]
}

const p1 = object(person)
p1.name = 'r1'
p1. friends.push('x1')

const p2 = object(person)
p2.name = 'r2'
p2. friends.push('x2')

console.log(person.friends) // [1, 2, 3, 'x1', 'x2']
```

#### 解析

1. 要求传入的对象必须是一个可以作为基础对象的对象；
2. 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型（也就是子类）；
3. 本质上 `object` 对传入的对象执行了一次浅复制；
4. 引用类型属性始终都会共享；
5. `ECMAScript5` 通过新增的 `Object.create()` 规范了原型式继承，`Object.create()` 在传入一个参数时候同 `object` 行为相同；

::: tip Object.create()
1. `Object.create()` 在传入一个参数时候同 `object` 行为相同；
2. `Object.create()` 的第二个参数与 `Object.defineProperties()` 的第二参数的格式相同。

```js
const person = {
  name: 'reco',
  friends: [1, 2, 3]
}

const p1 = Object.create(person, {
  name: {
    value: 'luan'
  }
})

console.log(p1.name) // luan
```
:::

### 5. 寄生式继承

是 `原型式继承` 的进阶，也是 道格拉斯·克罗克福德 提出的。

```js
const person = {
  name: 'reco',
  friends: [1, 2, 3]
}

function createP (o) {
  const clone = object(o)
  clone.say = function () {
    console.log('hi')
  }
  return clone
}

const p1 = createP(person)
```

#### 解析

1. 思路和工厂模式一样，即将继承的过程封装成一个函数，在函数内部将对象做一些增强，比如创建一些方法，然后返回这个对象；
2. 示例代码中 `object` 函数并不是必须的，所有可以返回对象的函数均可，比如 `Object.create()`。


#### 缺点

与构造函数模式类似，使用寄生式继承为对象添加函数，会由于不能做到函数的复用而降低效率。

### 6. 寄生组合式继承

传统的组合继承最大的问题就是，无论什么情况下，都会调用两次父类构造函数：一次是创建子类原型时，另一次是在子类构造函数内部。这样导致一个问题是，创建子类原型时已经挂载了父类的全部实例属性，但是在子类实例化时，又这些属性挂载到了子类的实例属性中。

当然在上面提到使用 `Object.create()` 已经解决了这个问题，下面说一下其背后的思路：

我们不必为了指定子类的原型而调用父类的构造函数，我们需要的只是父类的一个副本而已。

:::tip
读到这里，我希望给一个提示，`组合继承` 包括实例属性继承和原型属性继承两部分，而 `寄生组合式继承` 相比 `组合继承`，改进的地方只有原型属性继承而已，所以不要把改进的部分当做是 `寄生组合式继承` 的全部.

下面的各种实现方式，都是针对 `原型属性继承` 的：
:::

```javascript
// 方法1
function inherits (Child, Parent) {
  const F = function () {}
  F.prototype = Parent.prototype
  Child.prototype = new F()
  Child.prototype.constructor = Child
}

// 方法2
function inherits (Child, Parent) {
  Child.prototype = Object.create(Parent.prototype)
  Child.prototype.constructor = Child
}

// JavaScript 高级程序设计提供案例
function inherits (Child, Parent) {
  const prototype = Object.create(Parent.prototype)
  prototype.constructor = Child
  Child.prototype = prototype
}
```

> 上面的第三种方法与方法2一样，但是它的表达方式感觉比方法2更合理，首先应该将原型改造完再赋值，方法1也可以按照这种表达方式来表达。

下面是完整的寄生组合式继承：

```js
function inherits (Child, Parent) {
  const prototype = Object.create(Parent.prototype)
  prototype.constructor = Child
  Child.prototype = prototype
}

function Parent () {
  this.name = 'reco'
}
Parent.prototype.say = function () {
  console.log('hello')
}

function Child () {
  // 切记，这一步继承实例属性相较于 组合继承 是不能省略的
  Parent.call(this)
  this.age = 10
}

// Child.prototype = new Parent()
inherits(Child, Parent)

console.log(new Child())
```
